Tabular Data Foundations
========================================================
author: Alejandro Schuler
date: 2022
transition: none
width: 1680
height: 1050

Adapted from [Steve Bagley](https://profiles.stanford.edu/steven-bagley) and based on [R for Data Science by Hadley Wickham](https://r4ds.had.co.nz/)

Edited by David Connell

```{r include=FALSE}
## better font size for slides
library(ggplot2)
theme_set(theme_grey(base_size = 22))
opts_chunk$set(collapse=TRUE,tidy=TRUE,prompt=TRUE,comment=NA,cache=FALSE)
opts_chunk$set(error=TRUE,warning=TRUE,message=TRUE)
```
<style>
.small-code pre code {
  font-size: 0.5em;
}
</style>

Introduction
========================================================
type: section


Goals of this course
========================================================
By the end of these slides you should be able to...

- write simple R scripts
- find, read, and understand package and function documentation 
- read and write tabular data into R from CSV files
- manipulate and subset tabular data

![](images/data-science.png)

Resources for this tutorial
========================================================

## Tidyverse

- The tidyverse collection of R packages is used in this tutorial, and in PHW142, to provide lots of additional functionality that's not present in the basic R programming language.

![](images/tidyverse.png)

Resources for this tutorial
========================================================

![](https://r4ds.had.co.nz/cover.png)

***
## [R for Data Science (R4DS) free online book by Hadley Wickham](https://r4ds.had.co.nz)

- Fundamentals: ch 1, 4, 6
- Input/output: ch 11
- Data manipulation: ch 5, 13
- Visualization: ch 3, 28

## [RStudio cheatsheets](https://www.rstudio.com/resources/cheatsheets/)

- Extremely useful reference guides for functions used in this tutorial

RStudio
========================================================
type: section


The basics of interaction using the console window
========================================================

If you haven't already, please open RStudio on DataHub by [clicking this link](https://publichealth.datahub.berkeley.edu/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fpre-142-training%2Ftutorial-playground&urlpath=rstudio%2F&branch=main). If you're viewing this on bCourses, you'll have to right click and then choose "Open Link in New Tab".

You will get more out of this tutorial if you try out these things in R yourself!!




A simple example in the console
========================================================

The R console window is the left (or lower-left) window in RStudio.

- The box contains an expression that will be evaluated by R, followed by the result of evaluating that expression.
```{r}
1 + 2
```
- `3` is the answer
- `[1]` means: the answer is a vector (a list of elements of the same type) and this line starts with the first element of that vector.
- It does not mean the answer has one element (although that is true in this case).

***

![](images/console.png)

Spaces (mostly) don't matter
========================================================
```{r eval=FALSE,tidy=FALSE}
1 +2
1+ 2
1+2
1 + 2
```

These all do the same thing. The result of each line is `3`:

```{r echo=FALSE,tidy=FALSE}
1 + 2
```

Basic calculations and vectors
========================================================
type: section

R is a scientific calculator
========================================================
```{r}
1 + 2 * 3 # R respects order of operations
3/4
6^3
log(10) # natural log
log10(10) # log base 10
sqrt(16)
```

Vectors
========================================================
```{r}
c(2.1, -4, 22)
```
- A vector is a one-dimensional sequence of zero or more numbers (or other values).
- Vectors are created by wrapping the values separated by commas with the `c(` `)` function, which is short for "combine"
```{r}
1:50
```
- The colon `:` is a handy shortcut to create a vector that is
a sequence of integers from the first number to the second number
(inclusive).
- Many R functions and operators automatically work when you input with
multi-element vectors.
- Long vectors wrap around. (Your screen may have a different width than what is shown here.)
- Look at the `[ ]` notation. The second output line starts
with 26, which is the 26^th element of the vector.
- This notation will help you figure out where you are in a long vector.

Elementwise operations on a vector
========================================================
  - An operation is elementwise (or element-wise) if the action you perform on a vector produces a vector with the same dimensions as the original.
 
  - The code below multiplies each element of `1:10` by the corresponding
element of `1:10`, that is, it squares each element.
```{r}
(1:10)*(1:10)
```
- Equivalently, we
could use exponentiation:
```{r}
(1:10)^2
```

Operator precedence: the rules
========================================================
- R does not evaluate strictly left to right.
- R respects the traditional mathematical order of operations ([PEMDAS](https://www.purplemath.com/modules/orderops.htm)), but R has special operators that have their own precedence, a kind of priority for
evaluation.
- For example, the sequence operator `:` has a higher precedence than addition `+`.
```{r}
1 + 0:10
0:10 + 1 # which operator gets executed first?
(0:10) + 1
0:(10 + 1)
```
- ADVANCED: check out [a complete list of R operators and their precedence](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html).

Variables
========================================================
type: section

Saving values by setting a variable
========================================================
```{r}
x <- 10
```
- To do more complex computations, we need to be able to give
names to things.
- Read this as "x gets 10" or "assign 10 to x"
- R prints no result from this assignment, but what you entered
causes a side effect: R has stored the association between
x and 10. (Look at the Environment pane.)

***

![](images/environment.png)


Using the value of a variable
========================================================
```{r}
x
x / 5
```
- When R sees the name of a variable, it uses the stored value of
that variable in the calculation.
- Here R uses the value of x, which is 10.
- `/` is the division operator.
- We can break complex calculations into named parts. This is a
simple, but very useful kind of abstraction.


Assignment has no undo
========================================================
```{r}
x <- 10
x
x <- x + 1
x
```
- If you assign to a name with an existing value, that value is overwritten.
- There is no way to undo an assignment, so be careful in reusing variable names.

Naming variables
========================================================
- It is important to pick meaningful variable names.
- Names can be too short, so don't use `x` and `y` everywhere.
- Names can be too long (`Main.database.first.object.header.length`).
- Avoid silly names.
- Pick names that will make sense to someone else (including the
person you will be in six months).
- ADVANCED: See `?make.names` for the complete rules on
what can be a name.


Case matters for names in R
========================================================
```{r, eval=F}
a <- 1
A # this causes an error because A does not have a value
```
```
Error: object 'A' not found
```
- R cares about upper and lower case in names.
- We also see that some error messages in R are a bit obscure.

Exercise: birth year
===
- Make a variable that represents the age you will be at the end of this year
- Make a variable that represents the current year
- Use them to compute the year of your birth and save that as a variable
- Print the value of that variable

Answer: birth year
===
```{r}
my_age_end_of_year = 31
this_year = 2022
my_birth_year = this_year - my_age_end_of_year
my_birth_year
```

Functions
========================================================
type: section

What is a function?
========================================================
+ Backbone of R programming language, majority of things you will do in R rely on them!
+ Set of statements that performs a specific task
+ User is able to call or pass information to the function
+ Function will perform task and return object or value or action

### Where do functions come from?
+ Many built into base R
+ Many many more available through different package libraries
+ Can create your own! (This will be covered later in the semester)



Source: OOMPH course PHW251 - R for Public Health

Calling built-in functions
========================================================
- To call a function, type the function name, then the argument or
arguments in parentheses. Arguments are the data and/or options we want the function to work on.
- Use a comma to separate the arguments, if more than one.
```{r}
sqrt(2)
```
- Many basic R functions operate on multi-element vectors as
easily as on vectors containing a single number.
```{r}
sqrt(0:10)
```

Functions and variable assignment
========================================================
```{r}
x <- 4
sqrt(x)
x
y <- sqrt(x)
y
x <- 10
y
```
- What do you observe about the value of `y` after changing the value of `x`?

Functions and variable assignment
========================================================
- functions generally do not affect the variables you pass to them (`x` remains the same after `sqrt(x)`)
- The results of a function call will simply be printed out if you do not save the result to a variable
- Saving the result to a variable lets you use it later, like any other variable you define manually
- Once a variable has been assigned (`y`), it keeps its value until updated, even if you change other variables (`x`) that went into the original assignment of that variable

Getting help in the RStudio console
========================================================
```{r eval=FALSE}
sum
```
- start typing `sum`, then hit the `TAB` key (or just wait a second)
- RStudio will display help on all functions that start `sum`.
- Use (up arrow, down arrow) to move through
the list.
- Use `RETURN` or `ENTER` to select the current
item.

Using the built-in help
========================================================
Type `?name` for help on name. Example:
```{r eval=FALSE,tidy=FALSE}
?log
```
- This will show information about the `log` function (and related functions) in the Help pane, including the name and meaning of the arguments and returned values.
- The help display is hyperlinked, so clicking on a blue link will take you to related material.
- R documentation often describes a set of functions, such as all the ones related to logarithms, on a single help page.
- Parts of the R documentation are rather obscure.


Getting help on operator symbols
========================================================
  ```{r eval=FALSE,tidy=FALSE,highlight=FALSE}
?"+"
```
- This will show help about the `+` operator.
- Put symbols in quotes to get help.


Exercise: convert weights
========================================================
```{r}
weights <- c(1.1, 2.2, 3.3)
```
- These weights are in pounds.
- Convert them to kilograms.
- (Hint: 2.2 lb = 1.0 kg)


Answer: convert weights
========================================================
```{r}
weights <- c(1.1, 2.2, 3.3)
# this divides the weights, element-wise, by the conversion factor:
weights / 2.2
```


Some functions operate on vectors and give back a single number
========================================================
```{r}
shoesize <- c(9, 12, 6, 10, 10, 16, 8, 4)
shoesize
sum(shoesize)
sum(shoesize)/length(shoesize)
mean(shoesize)
```


Exercise: subtract the mean
========================================================
```{r}
x <- c(7, 3, 1, 9)
```
- Subtract the mean of `x` from `x`, and then `sum`
the result.


Answer: subtract the mean
========================================================
```{r}
x <- c(7, 3, 1, 9)
mean(x)
x - mean(x)
sum(x - mean(x)) # answer in one expression
```


Exercise: compute a confidence interval
========================================================
```{r}
m <- 13
se <- 0.25
```
- Given the values of `m` (mean), and `se` (standard error), construct a vector containing the two values, $m \pm 2 \times se$.
- That is, add and subtract two times the standard error
value to/from the mean value.
- Your output should look like:
```{r, echo=FALSE}
m + c(-2, 2)*se
```


Answer: compute a confidence interval
========================================================
```{r}
## one way:
c(m - 2*se, m + 2*se)
## another way:
m + c(-2, 2)*se
```


Arguments by position
========================================================
```{r}
1:5
seq(1,5)
```
- `seq` is the function equivalent of the colon operator.
- Arguments can be specified by position, with one supplied
argument for each name in the function parameter list, and in the
same order.


Arguments by name
========================================================
```{r}
seq(from = 1, to = 5)
seq(to = 5, from = 1) # identical result
```
- Sometimes, arguments can be supplied by name using the syntax,
variable `=` value.
- When using names, the order of the named arguments
does not matter.
- You can mix positional and named arguments (carefully).
- Do not use `<-` in place of `=` when specifying
named arguments.


Using the correct argument name
========================================================
```{r}
seq(1, 5)
seq(from = 1, to = 5)
seq(begin = 1, end = 5)
```
- You have to use the correct argument names to get the correct results.


How to find the names of a function's arguments
========================================================
  - How can you figure out the names of seq's arguments? It is
a built-in function.
- Answer: the arguments are listed in the R documentation of the
function.
```{r eval=FALSE,tidy=FALSE}
# Try this:
?seq
```

Packages
============================================================
- An R package is a collection of functions and variables.
- Each package has a name.
- By default, when R starts up, the base packages
(datasets, utils, grDevices, graphics, stats, methods) are loaded
into the workspace for you.
- When you _install_ a package, a copy is downloaded from a server to a directory on your local machine, but not loaded
into the workspace.
- When you _load_ a package, the contents the package are
copied into the workspace.
- If you try to load a package that has not been installed, you
will get an error.
- These operations can be initiated from either the graphical user
interface or through the console.


Installing a package
============================================================
- When you install a package, R may prompt you to select a CRAN
mirror. This is the server that R will use when installing packages.
Pick one that is geographically close to you.
- In RStudio, select Packages, then Install Packages.
- Or:
```{r eval=FALSE}
install.packages("name_of_package")
```
Try this now:
```{r eval=FALSE}
install.packages("tidyverse")
```


Loading a package
============================================================
- Use the `library` function to load an installed package.
- Terminology alert: Note that `library` _loads_ a package,
not a library.
- Hint: Put the library call(s) at the top of every script file you write.
```{r eval=FALSE}
library("name_of_package")
```

Calling functions from a package
============================================================
- Sometimes packages introduce name conflicts, which is when the pacakge loads a function that is named the same thing as a function that's already in the environment
- Typically, the package being loaded will take precedence over what is already loaded.
- For instance:
```{r, eval=F}
?filter # returns documentation for a function called filter in the stats package
library(dplyr)
?filter # now returns documentation for a function called filter in the dplyr package!
```
- You can tell R which function you want by specifying the package name and then `::` before the function name
```{r, eval=F}
?stats::filter
?dplyr::filter
```
- This also works when calling the function in your code

RStudio scripts
============================================================
type: section


Using the script pane
============================================================
- Writing a series of expressions in the console rapidly gets
messy and confusing.
- The console window gets reset when you restart RStudio.
- It is better (and easier) to write expressions and functions
in the script pane (upper left), building up your analysis.
- There, you can enter expressions, evaluate them, and save the
contents to a .R file for later use.


Script pane example
============================================================
- Create a script pane: File > New File > R Script
- Put your cursor in the script pane.
- Type: `factorial(1:10)`
- Then hit `Command-RETURN` (Mac), or `Ctrl-ENTER` (Windows).
- That line is copied to the console pane and evaluated.
- You can save the script to a file.
- Explore the RStudio ``Code`` menu for other commands.

***

![](images/script.png)

Adding comments
========================================================
```{r}
# This is a comment
1 + 2 # add some numbers
```
- Use a `#` to start a comment.
- A comment extends to the end of the
line and is ignored by R.

Introduction to Data Manipulation
========================================================
type: section


Need to install the tidyverse set of packages
========================================================
If you're working in R locally (installed on your computer), you will need to install the tidyverse package. If you're on DataHub it has already been installed.

- Do this:
```{r eval=FALSE}
install.packages("tidyverse")
```
```{r }
library("tidyverse")
```
- "tidyverse" is a coherent set of packages for operating a kind of data called the "data frame".
- It is not built-in, so you need to install it (once), then load it each time you restart R.
- Put `library("tidyverse")` at the top of every script file.


Data frame: a two-dimensional data structure
========================================================
A data frame is one of the most powerful features in R.
- This is a compound data structure that can contain different
types of data, similar to an Excel spreadsheet.
- Typically, each row in a data frame contains information about one
instance of some (real-world) object.
- Each column can be thought of as a variable, containing the values for the corresponding instances.
- All the values in one column should be of the same type (a number, a category, text, etc.), but
different columns can be of different types.
- Each column is actually a vector, so a data frame is like a list of vectors

Data frame example
========================================================
```{r, include=F}
mtc = as_tibble(mtcars)
```
```{r}
mtc
```
- This data set contains data on 32 different cars.
- A `tibble` is a kind of data frame. This one has 32 rows and 11 columns.  We only see the first 10 rows because of limited slide/screen space.
- Across the top is the name of each column. The next row shows the type of data in the column. `<dbl>`, means double-precision floating point number, which is a computer science term for any number with a decimal point in it (e.g. `1.3333`, `3.14159`, `1.0`)

Data frame example
========================================================
```{r}
mtc
```
- Typically, each row in a data frame describes an
instance of some (real-world) object. (Yes: one row for each model of car.)
- Each column contains the values of a variable for the
corresponding instance. (Yes: one column for each variable.)

Reading in flat files
========================================================
```{r, eval=F}
mtc = read_csv("https://tinyurl.com/mtcars-csv")
```
- `read_csv` (from the `readr` package, part of `tidyverse`) reads in data frames that are stored in `.csv` files (.csv = comma-separated values)
- these files may be online (accessed via URL), or local, in which case the syntax is `read_csv("path/to/file/mtcars.csv")`
- try `?read_csv` to learn a bit more
- `.csv`s can also be exported from spreadsheets and databases and then saved locally to be read into R.

Making data frames
========================================================
- use `tibble()` to make your own data frames from scratch in R
```{r}
my_data = tibble( # newlines don't do anything, just increase code readability
  mrn = c(1, 2, 3, 4),
  age = c(33, 48, 8, 29)
)
my_data
```

Data frame properties
========================================================
- `dim()` gives the dimensions of the data frame. `ncol()` and `nrow()` give you the number of columns and the number of rows, respectively.
```{r}
dim(my_data)
ncol(my_data)
nrow(my_data)
```

- `names()` gives you the names of the columns (a vector)
```{r}
names(my_data)
```

Data frame properties
========================================================
- `glimpse()` shows you a lot of information
```{r}
glimpse(my_data)
```
- `head()` returns the first `n` rows
```{r}
head(my_data, n=2)
```

dplyr verbs
========================================================
The rest of this section shows the basic data frame functions ("verbs") in the `dplyr` package (part of `tidyverse`). Each operation takes a data frame and produces a new data frame.

- `filter()` picks out rows according to specified conditions
- `select()` picks out columns according to their names
- `arrange()` sorts the row by values in some column(s)
- `mutate()` creates new columns, often based on operations on other columns

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation. 

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result. Letâ€™s dive in and see how these verbs work.

filter() subsets the rows of a data frame
========================================================
```{r}
filter(mtc, mpg >= 25)
```
- This produces (and prints out) a new tibble (data frame), which contains all the rows where the mpg value in that row is greater than or equal to 25.
- There are only 6 rows in this data frame.
- There are still 11 columns.

Combining constraints in filter
========================================================
```{r}
filter(mtc, mpg >= 25, qsec < 19)
```
- This filters by the **conjunction** of the two constraints---both must be satisfied.
- Constraints appear as second (and third...) arguments, separated by commas.


Filtering out all rows
=========================================================
```{r}
filter(mtc, mpg > 60)
```
- If the constraint is too severe, then you will select **no** rows, and produce a zero row sized tibble.

Comparison operators
=========================================================
- `==` tests for equality (do not use `=` which is for assignment)
- `>` and `<` test for greater-than and less-than
- `>=` and `<=` are greater-than-or-equal and less-than-or-equal
- these can also be used directly on vectors outside of data frames
```{r}
c(1,5,-22,4) > 0
```

Logical conjunctions
=========================================================
```{r}
filter(mtc, mpg > 30 | mpg < 20)
```
- `|` stands for OR, `&` is AND
- as we have seen, separating conditions by a comma is the same as using `&` inside `filter()`
- these can be made into complex logical conditions 

Logical conjunctions
=========================================================
```{r}
filter(mtc, !(mpg > 30 | mpg < 20))
```
- `!` is NOT, which negates the logical condition

Logical conjunctions
=========================================================
```{r}
filter(mtc, cyl %in% c(6,8)) # equivalent to filter(mtc, cyl==6 | cyl==8)
```
- `%in%` returns true for all elements of the thing on the left that are also elements of the thing on the right

Exercise: cars with powerful engines
==========================================================
- How many cars have engines with horsepower (`hp`) greater than 200?


Answer: cars with powerful engines
===========================================================
```{r}
filter(mtc, hp > 200)
```
- Answer: 7


Exercise: filtering rows
========================================================
- List all cars with `mpg` between 15 and 20.


Answer: filtering rows
=========================================================
```{r}
filter(mtc, mpg > 15, mpg < 20)
```


Filtering by row number
==========================================================
```{r}
filter(mtc, row_number()<=3)
```
- use `row_number()` to get specific rows. This is more useful once you have sorted the data in a particular order, which we will soon see how to do.

Sampling rows
==========================================================
```{r}
sample_n(mtc, 5)
```
- You can use `sample_n()` to get `n` randomly selected rows if you don't have a particular condition you would like to filter on.
- `sample_frac()` is similar
- do `?sample_n()` to see how you can sample with replacement or with weights

select() subsets columns by name
=========================================================
```{r}
select(mtc, mpg, qsec, wt)
```
- The select function will return a subset of the tibble, using only the requested columns in the order specified.

select() subsets columns by name
=========================================================
- `select()` can also be used with handy helpers like `starts_with()` and `contains()`
```{r}
select(mtc, starts_with("m"))
```

select() subsets columns by name
=========================================================
- `select()` can also be used with handy helpers like `starts_with()` and `contains()`
```{r}
select(mtc, hp, contains("m"))
```
- The quotes around the letter `"m"` make it a character string (or string for short). If we did not do this, `R` would think it was looking for a variable called `m` and not just the plain letter. 
- We don't have to quote the names of columns (like `hp`) because the `tidyverse` functions know that we are working within the dataframe and thus treat the column names like they are variables in their own right

select() subsets columns by name
=========================================================
- `select()` can also be used to select everything **except for** certain columns by using the minus character `-`
```{r}
select(mtc, -contains("m"), -hp)
```

pull() is a friend of select()
=========================================================
- `select()` has a friend called `pull()` which returns a vector instead of a (one-column) data frame
```{r}
select(mtc, hp)
pull(mtc, hp)
```

Saving the result
=========================================================
```{r}
filter(mtc, row_number()==1)
head(mtc)
```
- `select()` and `filter()` are functions, so they do not modify their input. You can see `mtc` is unchanged after calling `filter()` on it. This holds for functions in general.

Saving the result
=========================================================
- To save a new version of mtc, use a variable
```{r}
mtc_first_row = filter(mtc, row_number()==1)
mtc_first_row
```

Combining filtering and selecting
=========================================================
- If the result of the operation will only be used by one other function, you can nest the calls:
```{r}
# tmp = select(mtc, mpg, qsec, wt)
# filter(tmp, mpg >= 25)
filter(select(mtc, mpg, qsec, wt), mpg >= 25)
```


arrange() sorts rows
===========================================================
- `arrange` takes a data frame and a column, and sorts the rows by the values in that column (ascending order).
```{r}
powerful <- filter(mtc, hp > 200)
arrange(powerful, mpg)
```

Arrange can sort by more than one column
===========================================================
- This is useful if there is a tie in sorting by the first column.
```{r}
arrange(powerful, gear, disp)
```


Use the desc function to sort by descending values
===========================================================
```{r}
arrange(powerful, desc(mpg))
```

Exercise: top 5 mpg cars
===========================================================
Use `arrange()` and `filter()` to get the data for the 5 cars with the highest mpg.

Answer: top 5 mpg cars
================================================================
```{r}
filter(arrange(mtc, desc(mpg)), row_number()<=5) # "nesting" the calls to filter and arrange
```
or
```{r}
cars_by_mpg = arrange(mtc, desc(mpg)) # using a temporary variable
filter(cars_by_mpg, row_number()<=5)
```

mutate() creates new columns
================================================================
```{r}
mtc_vars_subset = select(mtc, mpg, hp)
mutate(mtc_vars_subset, gpm = 1/mpg)
```
- This uses `mutate` to add a new column to which is the reciprocal of `mpg`.
- The thing on the left of the `=` is a new name that you make up which you would like the new column to be called
- The expression on the right of the `=` defines what will go into the new column
-mutate() can create multiple columns at the same time and use multiple columns to define a single new one

mutate() can create multiple new columns at once
================================================================
```{r}
mutate(mtc_vars_subset, # the newlines make it more readable
      gpm = 1/mpg,
      mpg_hp_ratio = mpg/hp) 
```
- As before, the result of this function is only saved if you assign it to a variable. In this example, `mtc_vars_subset` is unchanged after the mutate.

mutate() for data type conversion
===
- Data is sometimes given to you in a form that makes it difficult to do operations on
```{r}
df = tibble(number = c("1", "2", "3"))
mutate(df, number_plus_1 = number + 1)
```

- `mutate()` is also useful for converting data types, in this case text to numbers
```{r}
mutate(df, number = as.numeric(number)) 
```
- if you save the result into a column that already exists, it will be overwritten

dplyr verbs summary
========================================================

- `filter()` picks out rows according to specified conditions
- `select()` picks out columns according to their names
- `arrange()` sorts the row by values in some column(s)
- `mutate()` creates new columns, often based on operations on other columns

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.

dplyr cheatsheet
============================================================
[Download the full cheatsheet here](https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf)
![](images/dplyr.png)

Visualization basics
============================================================
type: section

ggplot2
=============================================================
- `ggplot2` is a very powerful graphics package.
- gg stands for "grammar of graphics"
- It was installed and loaded as part of `tidyverse`.
- Otherwise, you must do the following:
```{r eval=FALSE}
install.packages("ggplot2")
library("ggplot2")
```
```{r include=FALSE}
## better font size for slides
theme_set(theme_grey(base_size = 22))
```


A simple scatterplot
=============================================================
```{r}
ggplot(data = mtc, mapping = aes(x = hp, y = mpg)) + 
  geom_point()
```
- Note that, although the package is named `ggplot2`, the function is called simply `ggplot()`

How to call ggplot
==============================================================
```{r, prompt=FALSE,eval=FALSE,tidy=FALSE}
ggplot(data = mtc, mapping = aes(x = hp, y = mpg)) + geom_point()
```
- `data = mtc`: this tells which tibble contains the data to be plotted
- `mapping = aes(x = hp, y = mpg)`: use the data in the hp column on x-axis, mpg column on y-axis
- `geom_point()`: plot the data as points
- Note that you can use positional instead of named arguments to make this expression shorter:
```{r prompt=FALSE,eval=FALSE}
ggplot(mtc, aes(hp, mpg)) + 
  geom_point()
```
- The use of "+" to glue these operations together will be explained later.


Change points to lines
===============================================================
```{r}
ggplot(mtc, aes(hp, mpg)) + 
  geom_line()
```
- This is pretty ugly. Line plots are better for time series.


Fit straight line to points
===============================================================
```{r}
ggplot(mtc, aes(hp, mpg)) + 
  geom_point() + 
  geom_smooth(method="lm")
```
- `"lm"` means "linear model," which is a least-squares regression line.
- The gray band is the confidence interval.


Fit smooth line to points
================================================================
```{r}
ggplot(mtc, aes(hp, mpg)) + 
  geom_point() + 
  geom_smooth(method="loess")
```
- "loess" fits a collection of tiny regression lines, then glues them together.
- This is a better approximation than a straight line for these data.


Plotting categorical variables
====================================================================
First, let's load in some new data.
```{r, warn=F}
data1 <- read_csv("https://raw.githubusercontent.com/pre-142-training/r4ds-courses/fa8642362bf9aa1a6423988ea6d2816d7cb9c39f/data/data1.csv")
data1
```
- `<chr>` is short for "character string", which means text data

Plotting categorical variables
====================================================================

```{r}
data1 %>%
  ggplot(aes(x = name, shoesize)) + 
  geom_col()
```
- `geom_col()` is used to make a bar plot. Height of bar is the value for that individual

The grammar of graphics
============================================================
- Most graphics systems are a large collection of functions to call to
construct a graph piece by piece.
- `ggplot2` is different, and is based on the idea of a "grammar of
graphics," a set of primitives and rules for combining them in a way
that makes sense for plotting data.
- This perspective is quite powerful, but requires learning a bit of
vocabulary and a new way of thinking about graphics.


The ggplot2 model (simplified version)
============================================================
1. supply data frame (rows of observations, columns of variables)
2. use `aes` to map from variables (columns in data frame) to
aesthetics (visual properties of the plot): x, y, color, size,
shape, and others.
3. choose a `geom`. This determines the type of the plot: point (a
scatterplot), line (line graph or line chart), bar (barplot), and
others.
4. choose a `stat` (statistical transformation): often `identity` (do
no transformation), but can be used to count, bin, or summarize
data (e.g., in a histogram).
5. choose a `scale`. This converts from the units used in the data
frame to the units used for display.
6. provide optional facet specification.

ggplot2 cheatsheet
============================================================
[Download the full cheatsheet here](https://github.com/rstudio/cheatsheets/blob/main/data-visualization.pdf)

![](images/ggplot.png)

Putting it together
=================================================================
type: section

Exercise: Is there a linear relationship between hp and 1/mpg?
=================================================================
- Use `ggplot` to look for a linear relationship between `hp` and `1/mpg` in our `mtc` data


Answer: Is there a linear relationship between hp and 1/mpg?
=================================================================
```{r}
ggplot(mtc, aes(hp, 1/mpg)) + 
  geom_point() + 
  geom_smooth(method="lm", se=FALSE)
```
- So, probably "yes"

Answer: Is there a linear relationship between hp and 1/mpg?
=================================================================
- Could also have done:
```{r, eval=F}
mtc %>%
  mutate(gpm = 1/mpg) %>%
ggplot(aes(hp, gpm)) + 
  geom_point() + 
  geom_smooth(method="lm", se=FALSE)
```

Exercise: orange trees
=================================================================
```{r}
orange <- as_tibble(Orange) # this data is pre-loaded into R
```
1. Pull out the data for tree 2 only
2. Plot circumference versus age for those data

Answer: orange trees
==================================================================
```{r}
orange %>%
  filter(Tree == 2) %>%
ggplot(aes(age, circumference)) + 
  geom_point()
```


Exercise: more orange trees
============================================================
1. Pull out the data for tree 2 where `age > 1000`
2. Plot circumference versus age for those data

Answer: more orange trees
==================================================================
```{r}
orange %>%
  filter(Tree == 2, age > 1000) %>%
ggplot(aes(age, circumference)) + 
  geom_point()
```


Exercise: even more orange trees
============================================================
- Add a new column called `circum_in` which is the circumference in inches, not in millimeters.


Answer: even more orange trees
=================================================================
```{r}
mutate(orange, circum_in = circumference/(10 * 2.54))
```

Review: Resources for this course
========================================================

![](https://r4ds.had.co.nz/cover.png)

***
## [R for Data Science (R4DS) free online book by Hadley Wickham](https://r4ds.had.co.nz)

- Fundamentals: ch 1, 4, 6
- Input/output: ch 11
- Data manipulation: ch 5, 13
- Visualization: ch 3, 28

## [RStudio cheatsheets](https://www.rstudio.com/resources/cheatsheets/)

- Extremely useful reference guides for functions used in this course
